#2 Write python code to sort an array in descending order using bubble sort
def bubbleSort(array):
    swapped = False
    for i in range(len(array)-1,0,-1):
        for j in range(i):
            if array[j]<array[j+1]:
                array[j], array[j+1] = array[j+1], array[j]
                swapped= True
        if swapped:
            swapped=False
        else:
            break
    return array
arr = [9,4,3,5,6,1,2,7]
print(bubbleSort(arr))




#4 write a python program to check if any value appears at least twice in the array using Bubble Sort Algorithm
def bubbleSort(array):
    swapped = False
    for i in range(len(array)-1,0,-1):
        for j in range(i):
            if array[j]>array[j+1]:
                array[j], array[j+1] = array[j+1], array[j]
                swapped= True
        if swapped:
            swapped=False
        else:
            break
    return array
arr = [1,2,3,1]
arr = bubbleSort(arr)
for i in range(len(arr)-1):
    if arr[i] == arr[i+1]:
        print("A value appears at least twice in the array")
        break
    else:
        if (i+1 == len(arr)-1):
            print("No value appear twice in the array")




#13 Write python code to determine the element that appears more than ⌊n / 2⌋ times in an array using Selection Sort assuming that this element always exists in the array
def selectionSort(array):
    for i in range(len(array)-1):
        min_idx = i
        for idx in range(i + 1, len(array)):
            if array[idx] < array[min_idx]:
                min_idx = idx
        array[i], array[min_idx] = array[min_idx], array[i]
    return array
arr = [2,2,1,1,1,2,2]
arr = selectionSort(arr)
print(arr[len(arr)//2])




#15 Use the Selection Sort algorithm to find the third distinct maximum number in an array in python
def selectionSort(array):
    for i in range(len(array)-1):
        min_idx = i
        for idx in range(i + 1, len(array)):
            if array[idx] < array[min_idx]:
                min_idx = idx
        array[i], array[min_idx] = array[min_idx], array[i]
    return array
arr = [2,2,3,1]
arr = selectionSort(arr)
count = 1
prev = arr[0]
for i in range(len(arr)):
    if arr[i] != prev:
        count += 1
        prev = arr[i]
        if count == 3:
            print(arr[i])




#24 Write python code to check if any value appears at least two times in an array using Insertion Sort
def insertionSort(array):
    for i in range(1, len(array)):
        key = array[i]
        j = i-1
        while array[j] > key and j >= 0:
            array[j+1] = array[j]
            j -= 1
        array[j+1] = key
    return array
arr = [1,2,3,1]
arr = insertionSort(arr)
for i in range(len(arr)-1):
    if arr[i] == arr[i+1]:
        print("A value appears at least twice in the array")
        break
    else:
        if (i+1 == len(arr)-1):
            print("No value appear twice in the array")




#26 write a python program that uses insertion sort algorithm to find three element in an array whose product is the highest
def insertionSort(array):
    for i in range(1, len(array)):
        key = array[i]
        j = i-1
        while array[j] > key and j >= 0:
            array[j+1] = array[j]
            j -= 1
        array[j+1] = key
    return array
arr = [1,2,3,4]
arr = insertionSort(arr)
print(max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1]))




#35 write python code to determine the third distinct maximum number in this array using shell sort algorithm
import math
def shellSort(array):
    n = len(array)
    k = int(math.log2(n))
    interval = 2**k -1
    while interval > 0:
        for i in range(interval, n):
            temp = array[i]
            j = i
            while j >= interval and array[j - interval] > temp:
                array[j] = array[j - interval]
                j -= interval
            array[j] = temp
        k -= 1
        interval = 2**k -1
    return array
arr = [2,2,3,1]
arr = shellSort(arr)
count = 1
prev = arr[0]
for i in range(len(arr)):
    if arr[i] != prev:
        count += 1
        prev = arr[i]
        if count == 3:
            print(arr[i])




#37 Write a shell sort based Python program to determine the biggest perimeter of a triangle with a non-zero area built from three of these lengths
import math
def shellSort(array):
    n = len(array)
    k = int(math.log2(n))
    interval = 2**k -1
    while interval > 0:
        for i in range(interval, n):
            temp = array[i]
            j = i
            while j >= interval and array[j - interval] > temp:
                array[j] = array[j - interval]
                j -= interval
            array[j] = temp
        k -= 1
        interval = 2**k -1
    return array
arr = [2,1,2]
arr = shellSort(arr)[::-1]
for i in range(len(arr)-2):
    if arr[i] + arr[i+1] > arr[i+2]:
        print(arr[i] + arr[i+1] + arr[i+2])




#46 Use heap sort algorithm to find three numbers whose product is maximum in a given array
def heapify(array, n, i):
    smallest = i
    l = 2 * i + 1
    r = 2 * i + 2
    if l < n and array[i] < array[l]:
        smallest = l
    if r < n and array[smallest] < array[r]:
        smallest = r
    if smallest != i:
        array[i], array[smallest] = array[smallest], array[i]
        heapify(array, n, smallest)
def heapSort(array):
    n = len(array)
    for i in range(n//2, -1, -1):
        heapify(array, n, i)
    for i in range(n-1, 0, -1):
        array[i], array[0] = array[0], array[i]
        heapify(array, i, 0)
    return array
arr = [1,2,3,4]
arr = heapSort(arr)
print(max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1]))




#48 Write a python program that uses heap sort to print an array of each number's squares sorted in non-decreasing order from a specified array
def heapify(array, n, i):
    smallest = i
    l = 2 * i + 1
    r = 2 * i + 2
    if l < n and array[i] < array[l]:
        smallest = l
    if r < n and array[smallest] < array[r]:
        smallest = r
    if smallest != i:
        array[i], array[smallest] = array[smallest], array[i]
        heapify(array, n, smallest)
def heapSort(array):
    n = len(array)
    for i in range(n//2, -1, -1):
        heapify(array, n, i)
    for i in range(n-1, 0, -1):
        array[i], array[0] = array[0], array[i]
        heapify(array, i, 0)
    return array
arr = [-2,-1,0,3,4]
for i in range(len(arr)):
    arr[i] *= arr[i]
print(heapSort(arr))




#57 Write a Python programme to use merge sort to determine the biggest perimeter of a triangle with a non-zero area generated from three of these lengths
def mergeSort(nums):
    if len(nums)==1:
        return nums
    mid = (len(nums)-1) // 2
    lst1 = mergeSort(nums[:mid+1])
    lst2 = mergeSort(nums[mid+1:])
    result = merge(lst1, lst2)
    return result
def merge(lst1, lst2):
    lst = []
    i = 0
    j = 0
    while(i<=len(lst1)-1 and j<=len(lst2)-1):
        if lst1[i]<lst2[j]:
            lst.append(lst1[i])
            i+=1
        else:
            lst.append(lst2[j])
            j+=1
    if i>len(lst1)-1:
        while(j<=len(lst2)-1):
            lst.append(lst2[j])
            j+=1
    else:
        while(i<=len(lst1)-1):
            lst.append(lst1[i])
            i+=1
    return lst
arr = [2,1,2]
arr = mergeSort(arr)[::-1]
for i in range(len(arr)-2):
    if arr[i] + arr[i+1] > arr[i+2]:
        print(arr[i] + arr[i+1] + arr[i+2])




#59 write a merge sort-based Python programme to find the mean of the remaining integers after the smallest 5% and largest 5% of the array's elements have been eliminated
def mergeSort(nums):
    if len(nums)==1:
        return nums
    mid = (len(nums)-1) // 2
    lst1 = mergeSort(nums[:mid+1])
    lst2 = mergeSort(nums[mid+1:])
    result = merge(lst1, lst2)
    return result
def merge(lst1, lst2):
    lst = []
    i = 0
    j = 0
    while(i<=len(lst1)-1 and j<=len(lst2)-1):
        if lst1[i]<lst2[j]:
            lst.append(lst1[i])
            i+=1
        else:
            lst.append(lst2[j])
            j+=1
    if i>len(lst1)-1:
        while(j<=len(lst2)-1):
            lst.append(lst2[j])
            j+=1
    else:
        while(i<=len(lst1)-1):
            lst.append(lst1[i])
            i+=1
    return lst
arr = [1,3,3,2,2,2,2,2,2,2,2,3,3,1]
arr = mergeSort(arr)
start = int(len(arr)*5/100)
arr2 = arr[start:len(arr)-start]
print(sum(arr2)/len(arr2))




#68 Write a python program that uses quick sort to print an array of each number's squares arranged in non-decreasing order from a specified array
def quickSort(array):
    if len(array)> 1:
        pivot=array.pop()
        grtr_lst, equal_lst, smlr_lst = [], [pivot], []
        for item in array:
            if item == pivot:
                equal_lst.append(item)
            elif item > pivot:
                grtr_lst.append(item)
            else:
                smlr_lst.append(item)
        return (quickSort(smlr_lst) + equal_lst + quickSort(grtr_lst))
    else:
        return array
arr = [-2,-1,0,3,4]
for i in range(len(arr)):
    arr[i] *= arr[i]
print(quickSort(arr))




#70 write a quick sort function in python to determine the number of numbers in the array that are smaller than each entry
def quickSort(array):
    if len(array)> 1:
        pivot=array.pop()
        grtr_lst, equal_lst, smlr_lst = [], [pivot], []
        for item in array:
            if item == pivot:
                equal_lst.append(item)
            elif item > pivot:
                grtr_lst.append(item)
            else:
                smlr_lst.append(item)
        return (quickSort(smlr_lst) + equal_lst + quickSort(grtr_lst))
    else:
        return array
arr = [6,5,4,8]
arr2 = quickSort(arr.copy())
print([arr2.index(i) for i in arr])




#71 write python code to sort an array in ascending order using counting sort algorithm
def countSort(array):
    i_lower_bound , upper_bound = min(array), max(array)
    lower_bound = i_lower_bound
    if i_lower_bound < 0:
        lb = abs(i_lower_bound)
        array = [item + lb for item in array]
        lower_bound , upper_bound = min(array), max(array)
    counter_array = [0]*(upper_bound-lower_bound+1)
    for item in array:
        counter_array[item-lower_bound] += 1
    pos = 0
    for idx, item in enumerate(counter_array):
        num = idx + lower_bound
        for i in range(item):
            array[pos] = num
            pos += 1
    if i_lower_bound < 0:
        lb = abs(i_lower_bound)
        array = [item - lb for item in array]
    return array
arr = [9,4,3,5,6,1,2,7]
print(countSort(arr))




#73 write python code to find the element that appears more than ⌊n / 2⌋ times in an array using counting sort assuming that this element always exists in the array
def countSort(array):
    i_lower_bound , upper_bound = min(array), max(array)
    lower_bound = i_lower_bound
    if i_lower_bound < 0:
        lb = abs(i_lower_bound)
        array = [item + lb for item in array]
        lower_bound , upper_bound = min(array), max(array)
    counter_array = [0]*(upper_bound-lower_bound+1)
    for item in array:
        counter_array[item-lower_bound] += 1
    pos = 0
    for idx, item in enumerate(counter_array):
        num = idx + lower_bound
        for i in range(item):
            array[pos] = num
            pos += 1
    if i_lower_bound < 0:
        lb = abs(i_lower_bound)
        array = [item - lb for item in array]
    return array
arr = [2,2,1,1,1,2,2]
arr = countSort(arr)
print(arr[len(arr)//2])




#82 Write a python program to use the radix sort algorithm to sort an array in descending order
import itertools
def radixSort(array):
    min_num = min(array)
    if min_num < 0:
        lb = abs(min_num)
        array = [item + lb for item in array]
    n_digits = len(str(max(array)))
    for dgt in range(n_digits):
        buckets = [[] for i in range(10)]
        for num in array:
            idx = (num // (10**dgt)) % 10
            buckets[idx].append(num)
        array = list(itertools.chain(*buckets))
    if min_num < 0:
        lb = abs(min_num)
        array = [item - lb for item in array]
    return array[::-1]
arr = [9,4,3,5,6,1,2,7]
print(radixSort(arr))




#84 write a python program that uses Radix Sort algorithm to determine if any value appears at least twice in the array.
import itertools
def radixSort(array):
    min_num = min(array)
    if min_num < 0:
        lb = abs(min_num)
        array = [item + lb for item in array]
    n_digits = len(str(max(array)))
    for dgt in range(n_digits):
        buckets = [[] for i in range(10)]
        for num in array:
            idx = (num // (10**dgt)) % 10
            buckets[idx].append(num)
        array = list(itertools.chain(*buckets))
    if min_num < 0:
        lb = abs(min_num)
        array = [item - lb for item in array]
    return array
arr = [1,2,3,1]
arr = radixSort(arr)
for i in range(len(arr)-1):
    if arr[i] == arr[i+1]:
        print("A value appears at least twice in the array")
        break
    else:
        if (i+1 == len(arr)-1):
            print("No value appear twice in the array")




#93 Write python code to find the element that appears more than ⌊n / 2⌋ times in an array using bucket sort, assume that this element always exists in the array
def bucketSort(array):
    largest = max(array)
    length = len(array)
    size = largest/length
    buckets = [[] for i in range(length)]
    for i in range(length):
        index = int(array[i]/size)
        if index != length:
            buckets[index].append(array[i])
        else:
            buckets[length - 1].append(array[i])
    for i in range(len(array)):
        buckets[i] = sorted(buckets[i])
    result = []
    for i in range(length):
        result = result + buckets[i]
    return result
arr = [2,2,1,1,1,2,2]
arr = bucketSort(arr)
print(arr[len(arr)//2])




#95 write a python program to use bucket sort to identify the third distinct maximum number in a given array
def bucketSort(array):
    largest = max(array)
    length = len(array)
    size = largest/length
    buckets = [[] for i in range(length)]
    for i in range(length):
        index = int(array[i]/size)
        if index != length:
            buckets[index].append(array[i])
        else:
            buckets[length - 1].append(array[i])
    for i in range(len(array)):
        buckets[i] = sorted(buckets[i])
    result = []
    for i in range(length):
        result = result + buckets[i]
    return result
arr = [2,2,3,1]
arr = bucketSort(arr)
count = 1
prev = arr[0]
for i in range(len(arr)):
    if arr[i] != prev:
        count += 1
        prev = arr[i]
        if count == 3:
            print(arr[i])




#104 Write a python program that uses the Random Pivot Quick Sort to determine if any value appears in the array at least twice
import random

def partition(A, left_index, right_index):
    pivot = A[left_index]
    i = left_index + 1
    for j in range(left_index + 1, right_index):
        if A[j] < pivot:
            A[j], A[i] = A[i], A[j]
            i += 1
    A[left_index], A[i - 1] = A[i - 1], A[left_index]
    return i - 1

def quick_sort_random(A, left, right):
    if left < right:
        pivot = random.randint(left, right - 1)
        A[pivot], A[left] = (A[left], A[pivot])
        pivot_index = partition(A, left, right)
        quick_sort_random(A, left, pivot_index)
        quick_sort_random(A, pivot_index + 1, right)

arr = [1,2,3,1]
quick_sort_random(arr, 0, len(arr))
for i in range(len(arr)-1):
    if arr[i] == arr[i+1]:
        print("A value appears at least twice in the array")
        break
    else:
        if (i+1 == len(arr)-1):
            print("No value appear twice in the array")




#106 Write a python program that uses the Random Pivot Quick Sort to locate the three values in an array whose product is the highest.
import random

def partition(A, left_index, right_index):
    pivot = A[left_index]
    i = left_index + 1
    for j in range(left_index + 1, right_index):
        if A[j] < pivot:
            A[j], A[i] = A[i], A[j]
            i += 1
    A[left_index], A[i - 1] = A[i - 1], A[left_index]
    return i - 1

def quick_sort_random(A, left, right):
    if left < right:
        pivot = random.randint(left, right - 1)
        A[pivot], A[left] = (A[left], A[pivot])
        pivot_index = partition(A, left, right)
        quick_sort_random(A, left, pivot_index)
        quick_sort_random(A, pivot_index + 1, right)
        
arr = [1,2,3,4]
quick_sort_random(arr, 0, len(arr))
print(max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1]))




#115 Write a python program to use recursive bubble sort to identify the third distinct maximum number in an array
def rec_bubble_sort(list_data: list, length: int = 0) -> list:
    length = length or len(list_data)
    swap = False
    for i in range(length - 1):
        if list_data[i] > list_data[i + 1]:
            list_data[i], list_data[i + 1] = list_data[i + 1], list_data[i]
            swap = True

    return list_data if not swap else rec_bubble_sort(list_data, length - 1)

arr = [2,2,3,1]
arr = rec_bubble_sort(arr)
count = 1
prev = arr[0]
for i in range(len(arr)):
    if arr[i] != prev:
        count += 1
        prev = arr[i]
        if count == 3:
            print(arr[i])




#117 write a python program that uses recursive bubble sort to discover the biggest perimeter of a triangle with a non-zero area generated from three of these lengths
def rec_bubble_sort(list_data: list, length: int = 0) -> list:
    length = length or len(list_data)
    swap = False
    for i in range(length - 1):
        if list_data[i] > list_data[i + 1]:
            list_data[i], list_data[i + 1] = list_data[i + 1], list_data[i]
            swap = True

    return list_data if not swap else rec_bubble_sort(list_data, length - 1)

arr = [2,1,2]
arr = rec_bubble_sort(arr)[::-1]
for i in range(len(arr)-2):
    if arr[i] + arr[i+1] > arr[i+2]:
        print(arr[i] + arr[i+1] + arr[i+2])




#126 write a python program using recursive quick sort to find the three numbers in an array whose product is the highest.
def rec_quick_sort(nums_list: list) -> list:
    if len(nums_list) <= 1:
        return nums_list
    else:
        return (rec_quick_sort([el for el in nums_list[1:] if el <= nums_list[0]]) + [nums_list[0]] + rec_quick_sort([el for el in nums_list[1:] if el > nums_list[0]]))

arr = [1,2,3,4]
arr = rec_quick_sort(arr)
print(max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1]))




#128 write a python program that uses recursive quick sort to print an array of each number's squares sorted in non-decreasing order from a given array.
def rec_quick_sort(nums_list: list) -> list:
    if len(nums_list) <= 1:
        return nums_list
    else:
        return (rec_quick_sort([el for el in nums_list[1:] if el <= nums_list[0]]) + [nums_list[0]] + rec_quick_sort([el for el in nums_list[1:] if el > nums_list[0]]))

arr = [-2,-1,0,3,4]
for i in range(len(arr)):
    arr[i] *= arr[i]
print(rec_quick_sort(arr))




#137 write a python program that uses strand sort and three of these lengths to get the biggest perimeter of a triangle with a non-zero area.
import operator
def strand_sort(num_arr: list, reverse: bool = False, solution: list = None) -> list:
    _operator = operator.lt if reverse else operator.gt
    solution = solution or []
    if not num_arr:
        return solution
    sublist = [num_arr.pop(0)]
    for k, item in enumerate(num_arr):
        if _operator(item, sublist[-1]):
            sublist.append(item)
            num_arr.pop(k)

    #  merging sublist into solution list
    if not solution:
        solution.extend(sublist)
    else:
        while sublist:
            item = sublist.pop(0)
            for j, xx in enumerate(solution):
                if not _operator(item, xx):
                    solution.insert(j, item)
                    break
            else:
                solution.append(item)

    strand_sort(num_arr, reverse, solution)
    return solution

arr = [2,1,2]
arr = strand_sort(arr)[::-1]
for i in range(len(arr)-2):
    if arr[i] + arr[i+1] > arr[i+2]:
        print(arr[i] + arr[i+1] + arr[i+2])




#139 Write a python program that uses strand sort to eliminate the least 5% and largest 5% of the array's members to determine the mean of the remaining integers.
import operator
def strand_sort(num_arr: list, reverse: bool = False, solution: list = None) -> list:
    _operator = operator.lt if reverse else operator.gt
    solution = solution or []
    if not num_arr:
        return solution
    sublist = [num_arr.pop(0)]
    for k, item in enumerate(num_arr):
        if _operator(item, sublist[-1]):
            sublist.append(item)
            num_arr.pop(k)

    #  merging sublist into solution list
    if not solution:
        solution.extend(sublist)
    else:
        while sublist:
            item = sublist.pop(0)
            for j, xx in enumerate(solution):
                if not _operator(item, xx):
                    solution.insert(j, item)
                    break
            else:
                solution.append(item)

    strand_sort(num_arr, reverse, solution)
    return solution

arr = [1,3,3,2,2,2,2,2,2,2,2,3,3,1]
arr = strand_sort(arr)
start = int(len(arr)*5/100)
arr2 = arr[start:len(arr)-start]
print(sum(arr2)/len(arr2))




#148 Write a python program that uses pancake sort to print an array of each number's squares in non-decreasing order
def pancake_sort(nums_list):
    arr_len = len(nums_list)
    while arr_len > 1:
        mi = nums_list.index(max(nums_list[0:arr_len]))
        nums_list = nums_list[mi::-1] + nums_list[mi+1:len(nums_list)]
        nums_list = nums_list[arr_len-1::-1] + nums_list[arr_len:len(nums_list)]
        arr_len -= 1
    return nums_list

arr = [-2,-1,0,3,4]
for i in range(len(arr)):
    arr[i] *= arr[i]
print(pancake_sort(arr))




#150 write a pancake sort program in Python to determine how many values in the array are less than each element
def pancake_sort(nums_list):
    arr_len = len(nums_list)
    while arr_len > 1:
        mi = nums_list.index(max(nums_list[0:arr_len]))
        nums_list = nums_list[mi::-1] + nums_list[mi+1:len(nums_list)]
        nums_list = nums_list[arr_len-1::-1] + nums_list[arr_len:len(nums_list)]
        arr_len -= 1
    return nums_list

arr = [6,5,4,8]
arr2 = pancake_sort(arr.copy())
print([arr2.index(i) for i in arr])




#151 Write a python program for Iterative Quick Sort to order an array in ascending order
def partition(arr,low,high):
    i = ( low - 1 )
    x = arr[high]
 
    for j in range(low , high):
        if   arr[j] <= x:
            i = i+1
            arr[i],arr[j] = arr[j],arr[i]
 
    arr[i+1],arr[high] = arr[high],arr[i+1]
    return (i+1)

def quickSortIterative(arr,low,high):
 
    size = high - low + 1
    stack = [0] * (size)
 
    top = -1
 
    top = top + 1
    stack[top] = low
    top = top + 1
    stack[top] = high
 
    while top >= 0:
        
        high = stack[top]
        top = top - 1
        low = stack[top]
        top = top - 1
 
        p = partition( arr, low, high )
        
        if p-1 > low:
            top = top + 1
            stack[top] = low
            top = top + 1
            stack[top] = p - 1
 
        if p+1 < high:
            top = top + 1
            stack[top] = p + 1
            top = top + 1
            stack[top] = high

arr = [9,4,3,5,6,1,2,7]
quickSortIterative(arr, 0, len(arr)-1)
print(arr)




#153 write a python program to find the element that appears more than ⌊n / 2⌋ times in an array using Iterative Quick Sort, assume that this element always exists in the array
def partition(arr,low,high):
    i = ( low - 1 )
    x = arr[high]
 
    for j in range(low , high):
        if   arr[j] <= x:
            i = i+1
            arr[i],arr[j] = arr[j],arr[i]
 
    arr[i+1],arr[high] = arr[high],arr[i+1]
    return (i+1)

def quickSortIterative(arr,low,high):
 
    size = high - low + 1
    stack = [0] * (size)
 
    top = -1
 
    top = top + 1
    stack[top] = low
    top = top + 1
    stack[top] = high
 
    while top >= 0:
        
        high = stack[top]
        top = top - 1
        low = stack[top]
        top = top - 1
 
        p = partition( arr, low, high )
        
        if p-1 > low:
            top = top + 1
            stack[top] = low
            top = top + 1
            stack[top] = p - 1
 
        if p+1 < high:
            top = top + 1
            stack[top] = p + 1
            top = top + 1
            stack[top] = high

arr = [2,2,1,1,1,2,2]
quickSortIterative(arr, 0, len(arr)-1)
print(arr[len(arr)//2])




#162 Write a python program to use Binary Insertion Sort to sort an array in descending order
def binary_search(arr, val, start, end):
    if start == end:
        if arr[start] > val:
            return start
        else:
            return start+1

    if start > end:
        return start
 
    mid = int((start+end)/2)
    if arr[mid] < val:
        return binary_search(arr, val, mid+1, end)
    elif arr[mid] > val:
        return binary_search(arr, val, start, mid-1)
    else:
        return mid
 
def bin_insertion_sort(arr):
    for i in range(1, len(arr)):
        val = arr[i]
        j = binary_search(arr, val, 0, i-1)
        arr = arr[:j] + [val] + arr[j:i] + arr[i+1:]
    return arr[::-1]

arr = [9,4,3,5,6,1,2,7]
print(bin_insertion_sort(arr))




#164 Write a python program that uses Binary Insertion Sort to determine if any value appears at least twice in the array
def binary_search(arr, val, start, end):
    if start == end:
        if arr[start] > val:
            return start
        else:
            return start+1

    if start > end:
        return start
 
    mid = int((start+end)/2)
    if arr[mid] < val:
        return binary_search(arr, val, mid+1, end)
    elif arr[mid] > val:
        return binary_search(arr, val, start, mid-1)
    else:
        return mid
 
def bin_insertion_sort(arr):
    for i in range(1, len(arr)):
        val = arr[i]
        j = binary_search(arr, val, 0, i-1)
        arr = arr[:j] + [val] + arr[j:i] + arr[i+1:]
    return arr

arr = [1,2,3,1]
arr = bin_insertion_sort(arr)
for i in range(len(arr)-1):
    if arr[i] == arr[i+1]:
        print("A value appears at least twice in the array")
        break
    else:
        if (i+1 == len(arr)-1):
            print("No value appear twice in the array")




#173 write a python program to find the element that appears more than ⌊n / 2⌋ times in an array using Iterative Merge Sort, assume that this element always exists in the array
def merge(left, right):
    if not len(left) or not len(right):
        return left or right
 
    result = []
    i, j = 0, 0
    while (len(result) < len(left) + len(right)):
        if left[i] < right[j]:
            result.append(left[i])
            i+= 1
        else:
            result.append(right[j])
            j+= 1
        if i == len(left) or j == len(right):
            result.extend(left[i:] or right[j:])
            break
 
    return result
 
def iter_merge_sort(list):
    if len(list) < 2:
        return list
 
    middle = int(len(list)/2)
    left = iter_merge_sort(list[:middle])
    right = iter_merge_sort(list[middle:])
 
    return merge(left, right)

arr = [2,2,1,1,1,2,2]
arr = iter_merge_sort(arr)
print(arr[len(arr)//2])




#175 Write a python program to use Iterative Merge Sort to find the third distinct maximum number in this array.
def merge(left, right):
    if not len(left) or not len(right):
        return left or right
 
    result = []
    i, j = 0, 0
    while (len(result) < len(left) + len(right)):
        if left[i] < right[j]:
            result.append(left[i])
            i+= 1
        else:
            result.append(right[j])
            j+= 1
        if i == len(left) or j == len(right):
            result.extend(left[i:] or right[j:])
            break
 
    return result
 
def iter_merge_sort(list):
    if len(list) < 2:
        return list
 
    middle = int(len(list)/2)
    left = iter_merge_sort(list[:middle])
    right = iter_merge_sort(list[middle:])
 
    return merge(left, right)

arr = [2,2,3,1]
arr = iter_merge_sort(arr)
count = 1
prev = arr[0]
for i in range(len(arr)):
    if arr[i] != prev:
        count += 1
        prev = arr[i]
        if count == 3:
            print(arr[i])




#184 Write a python program for Comb Sort to determine if any value appears in the array at least twice.
def getNextGap(gap):
    gap = (gap * 10)//13
    if gap < 1:
        return 1
    return gap
  
def combSort(arr):
    n = len(arr)
    gap = n
    swapped = True
    while gap !=1 or swapped == 1:
        gap = getNextGap(gap)
        swapped = False
        for i in range(0, n-gap):
            if arr[i] > arr[i + gap]:
                arr[i], arr[i + gap]=arr[i + gap], arr[i]
                swapped = True
    return arr

arr = [1,2,3,1]
arr = combSort(arr)
for i in range(len(arr)-1):
    if arr[i] == arr[i+1]:
        print("A value appears at least twice in the array")
        break
    else:
        if (i+1 == len(arr)-1):
            print("No value appear twice in the array")




#186 Use comb sort to find three elements in an array with the maximum product in python
def getNextGap(gap):
    gap = (gap * 10)//13
    if gap < 1:
        return 1
    return gap
  
def combSort(arr):
    n = len(arr)
    gap = n
    swapped = True
    while gap !=1 or swapped == 1:
        gap = getNextGap(gap)
        swapped = False
        for i in range(0, n-gap):
            if arr[i] > arr[i + gap]:
                arr[i], arr[i + gap]=arr[i + gap], arr[i]
                swapped = True
    return arr

arr = [1,2,3,4]
arr = combSort(arr)
print(max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1]))




#195 Write a python program that uses Pigeonhole Sort to find the third distinct maximum number in this array
def pigeonhole_sort(a):
    my_min = min(a)
    my_max = max(a)
    size = my_max - my_min + 1
  
    holes = [0] * size
  
    for x in a:
        assert type(x) is int, "integers only please"
        holes[x - my_min] += 1
  
    i = 0
    for count in range(size):
        while holes[count] > 0:
            holes[count] -= 1
            a[i] = count + my_min
            i += 1
    return a

arr = [2,2,3,1]
arr = pigeonhole_sort(arr)
count = 1
prev = arr[0]
for i in range(len(arr)):
    if arr[i] != prev:
        count += 1
        prev = arr[i]
        if count == 3:
            print(arr[i])




#197 write a python program to find the largest perimeter of a triangle with a non-zero area, formed from three of these lengths in an array using Pigeonhole Sort
def pigeonhole_sort(a):
    my_min = min(a)
    my_max = max(a)
    size = my_max - my_min + 1
  
    holes = [0] * size
  
    for x in a:
        assert type(x) is int, "integers only please"
        holes[x - my_min] += 1
  
    i = 0
    for count in range(size):
        while holes[count] > 0:
            holes[count] -= 1
            a[i] = count + my_min
            i += 1
    return a

arr = [2,1,2]
arr = pigeonhole_sort(arr)[::-1]
for i in range(len(arr)-2):
    if arr[i] + arr[i+1] > arr[i+2]:
        print(arr[i] + arr[i+1] + arr[i+2])




#206 write a python program to find three numbers whose product is maximum in an array using Cocktail Sort
def cocktailSort(a):
    n = len(a)
    swapped = True
    start = 0
    end = n-1
    while (swapped == True):
        swapped = False
        for i in range(start, end):
            if (a[i] > a[i + 1]):
                a[i], a[i + 1] = a[i + 1], a[i]
                swapped = True
 
        if (swapped == False):
            break
 
        swapped = False
        end = end-1

        for i in range(end-1, start-1, -1):
            if (a[i] > a[i + 1]):
                a[i], a[i + 1] = a[i + 1], a[i]
                swapped = True

        start = start + 1

arr = [1,2,3,4]
cocktailSort(arr)
print(max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1]))




#208 Write a python program to print an array of the squares of each number sorted in non-decreasing order of a given array using cocktail sort
def cocktailSort(a):
    n = len(a)
    swapped = True
    start = 0
    end = n-1
    while (swapped == True):
        swapped = False
        for i in range(start, end):
            if (a[i] > a[i + 1]):
                a[i], a[i + 1] = a[i + 1], a[i]
                swapped = True
 
        if (swapped == False):
            break
 
        swapped = False
        end = end-1

        for i in range(end-1, start-1, -1):
            if (a[i] > a[i + 1]):
                a[i], a[i + 1] = a[i + 1], a[i]
                swapped = True

        start = start + 1

arr = [-2,-1,0,3,4]
for i in range(len(arr)):
    arr[i] *= arr[i]
cocktailSort(arr)
print(arr)




#217 write a python program to find the largest perimeter of a triangle with a non-zero area, formed from three of these lengths in an array using gnome sort
def gnomeSort(arr):
    n = len(arr)
    index = 0
    while index < n:
        if index == 0:
            index = index + 1
        if arr[index] >= arr[index - 1]:
            index = index + 1
        else:
            arr[index], arr[index-1] = arr[index-1], arr[index]
            index = index - 1
 
    return arr

arr = [2,1,2]
arr = gnomeSort(arr)[::-1]
for i in range(len(arr)-2):
    if arr[i] + arr[i+1] > arr[i+2]:
        print(arr[i] + arr[i+1] + arr[i+2])




#219 write a python program to find the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements in an array using gnome sort
def gnomeSort(arr):
    n = len(arr)
    index = 0
    while index < n:
        if index == 0:
            index = index + 1
        if arr[index] >= arr[index - 1]:
            index = index + 1
        else:
            arr[index], arr[index-1] = arr[index-1], arr[index]
            index = index - 1
 
    return arr

arr = [1,3,3,2,2,2,2,2,2,2,2,3,3,1]
arr = gnomeSort(arr)
start = int(len(arr)*5/100)
arr2 = arr[start:len(arr)-start]
print(sum(arr2)/len(arr2))




#228 write a python program to print an array of the squares of each number sorted in non-decreasing order of a given array using Brick Sort
def BrickSort(l):
    n = len(l)
    is_Sorted = 0
    while is_Sorted == 0:
        is_Sorted = 1
        temp = 0
        for i in range(1, n-1, 2):
            if l[i] > l[i+1]:
                l[i], l[i+1] = l[i+1], l[i]
                is_Sorted = 0
                 
        for i in range(0, n-1, 2):
            if l[i] > l[i+1]:
                l[i], l[i+1] = l[i+1], l[i]
                is_Sorted = 0
     
    return l

arr = [-2,-1,0,3,4]
for i in range(len(arr)):
    arr[i] *= arr[i]
print(BrickSort(arr))




#230 write a python program to find out how many numbers in the array are smaller than each element using Brick Sort
def BrickSort(l):
    n = len(l)
    is_Sorted = 0
    while is_Sorted == 0:
        is_Sorted = 1
        temp = 0
        for i in range(1, n-1, 2):
            if l[i] > l[i+1]:
                l[i], l[i+1] = l[i+1], l[i]
                is_Sorted = 0
                 
        for i in range(0, n-1, 2):
            if l[i] > l[i+1]:
                l[i], l[i+1] = l[i+1], l[i]
                is_Sorted = 0
     
    return l

arr = [6,5,4,8]
arr2 = BrickSort(arr.copy())
print([arr2.index(i) for i in arr])




#231 Write a python program to sort an array in ascending order using Odd-Even Sort
def oddEvenSort(arr):
    n = len(arr)
    isSorted = 0
    while isSorted == 0:
        isSorted = 1
        temp = 0
        for i in range(1, n-1, 2):
            if arr[i] > arr[i+1]:
                arr[i], arr[i+1] = arr[i+1], arr[i]
                isSorted = 0
                 
        for i in range(0, n-1, 2):
            if arr[i] > arr[i+1]:
                arr[i], arr[i+1] = arr[i+1], arr[i]
                isSorted = 0
     
    return arr

arr = [9,4,3,5,6,1,2,7]
print(oddEvenSort(arr))




#233 write a python program to find the element that appears more than ⌊n / 2⌋ times in an array using Odd-Even Sort, assume that this element always exists in the array
def oddEvenSort(arr):
    n = len(arr)
    isSorted = 0
    while isSorted == 0:
        isSorted = 1
        temp = 0
        for i in range(1, n-1, 2):
            if arr[i] > arr[i+1]:
                arr[i], arr[i+1] = arr[i+1], arr[i]
                isSorted = 0
                 
        for i in range(0, n-1, 2):
            if arr[i] > arr[i+1]:
                arr[i], arr[i+1] = arr[i+1], arr[i]
                isSorted = 0
     
    return arr

arr = [2,2,1,1,1,2,2]
arr = oddEvenSort(arr)
print(arr[len(arr)//2])




#242 write a python program to sort an array in descending order using Permutation Sort
import random

def is_sorted(l):
    n = len(l)
    for i in range(0, n-1):
        if (l[i] > l[i+1] ):
            return False
    return True
 
def shuffle(l):
    n = len(l)
    for i in range (0,n):
        r = random.randint(0,n-1)
        l[i], l[r] = l[r], l[i]
 
def PermutationSort(l):
    n = len(l)
    while (is_sorted(l)== False):
        shuffle(l)
    return l

arr = [9,4,3,5,6,1,2,7]
print(PermutationSort(arr))




#244 write python code to check if any value appears at least twice in the array using Permutation Sort
import random

def is_sorted(l):
    n = len(l)
    for i in range(0, n-1):
        if (l[i] > l[i+1] ):
            return False
    return True
 
def shuffle(l):
    n = len(l)
    for i in range (0,n):
        r = random.randint(0,n-1)
        l[i], l[r] = l[r], l[i]
 
def PermutationSort(l):
    n = len(l)
    while (is_sorted(l)== False):
        shuffle(l)
    return l

arr = [1,2,3,1]
arr = PermutationSort(arr)
for i in range(len(arr)-1):
    if arr[i] == arr[i+1]:
        print("A value appears at least twice in the array")
        break
    else:
        if (i+1 == len(arr)-1):
            print("No value appear twice in the array")




#253 write a python program to find the element that appears more than ⌊n / 2⌋ times in an array using Bogo Sort, assume that this element always exists in the array
import random

def is_sorted(l):
    n = len(l)
    for i in range(0, n-1):
        if (l[i] > l[i+1] ):
            return False
    return True
 
def shuffle(l):
    n = len(l)
    for i in range (0,n):
        r = random.randint(0,n-1)
        l[i], l[r] = l[r], l[i]
 
def BogoSort(l):
    n = len(l)
    while (is_sorted(l)== False):
        shuffle(l)
    return l

arr = [2,2,1,1,1,2,2]
arr = BogoSort(arr)
print(arr[len(arr)//2])




#255 write a python program to find the third distinct maximum number in this array using Bogo Sort algorithm
import random

def is_sorted(l):
    n = len(l)
    for i in range(0, n-1):
        if (l[i] > l[i+1] ):
            return False
    return True
 
def shuffle(l):
    n = len(l)
    for i in range (0,n):
        r = random.randint(0,n-1)
        l[i], l[r] = l[r], l[i]
 
def BogoSort(l):
    n = len(l)
    while (is_sorted(l)== False):
        shuffle(l)
    return l

arr = [2,2,3,1]
arr = BogoSort(arr)
count = 1
prev = arr[0]
for i in range(len(arr)):
    if arr[i] != prev:
        count += 1
        prev = arr[i]
        if count == 3:
            print(arr[i])




#264 Write a python program to check if any value appears at least twice in the array using Cycle Sort
def cycleSort(array):

  for cycleStart in range(0, len(array) - 1):
    item = array[cycleStart]
     
    pos = cycleStart
    for i in range(cycleStart + 1, len(array)):
      if array[i] < item:
        pos += 1
     
    if pos == cycleStart:
      continue
     
    while item == array[pos]:
      pos += 1
    array[pos], item = item, array[pos]
     
    while pos != cycleStart:
       
      pos = cycleStart
      for i in range(cycleStart + 1, len(array)):
        if array[i] < item:
          pos += 1
       
      while item == array[pos]:
        pos += 1
      array[pos], item = item, array[pos]
   
  return array

arr = [1,2,3,1]
arr = cycleSort(arr)
for i in range(len(arr)-1):
    if arr[i] == arr[i+1]:
        print("A value appears at least twice in the array")
        break
    else:
        if (i+1 == len(arr)-1):
            print("No value appear twice in the array")




#266 write a python program to find three numbers whose product is maximum in an array using cycle sort
def cycleSort(array):

  for cycleStart in range(0, len(array) - 1):
    item = array[cycleStart]
     
    pos = cycleStart
    for i in range(cycleStart + 1, len(array)):
      if array[i] < item:
        pos += 1
     
    if pos == cycleStart:
      continue
     
    while item == array[pos]:
      pos += 1
    array[pos], item = item, array[pos]
     
    while pos != cycleStart:
       
      pos = cycleStart
      for i in range(cycleStart + 1, len(array)):
        if array[i] < item:
          pos += 1
       
      while item == array[pos]:
        pos += 1
      array[pos], item = item, array[pos]
   
  return array

arr = [1,2,3,4]
arr = cycleSort(arr)
print(max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1]))




#275 write a python program to find the third distinct maximum number in this array using Recursive Insertion Sort
def insertionSortRecursive(A, n):
    if n <= 1:
        return
 
    insertionSortRecursive(A, n - 1)
 
    last = A[n - 1]
    j = n - 2
 
    while (j >= 0 and A[j] > last):
        A[j + 1] = A[j]
        j = j - 1
    A[j + 1] = last

arr = [2,2,3,1]
insertionSortRecursive(arr, len(arr))
count = 1
prev = arr[0]
for i in range(len(arr)):
    if arr[i] != prev:
        count += 1
        prev = arr[i]
        if count == 3:
            print(arr[i])




#277 write a python program to find the largest perimeter of a triangle with a non-zero area, formed from three of these lengths in an array using Recursive Insertion Sort
def insertionSortRecursive(A, n):
    if n <= 1:
        return
 
    insertionSortRecursive(A, n - 1)
 
    last = A[n - 1]
    j = n - 2
 
    while (j >= 0 and A[j] > last):
        A[j + 1] = A[j]
        j = j - 1
    A[j + 1] = last

arr = [2,1,2]
insertionSortRecursive(arr, len(arr))
arr = arr[::-1]
for i in range(len(arr)-2):
    if arr[i] + arr[i+1] > arr[i+2]:
        print(arr[i] + arr[i+1] + arr[i+2])




#286 write a python program to find three numbers whose product is maximum in an array using stooge sort
def stoogesort(array, l, h):
 if l >= h:
  return

 if array[l]>array[h]:
  t = array[l]
  array[l] = array[h]
  array[h] = t
 
 if h-l+1 > 2:
  t = (int)((h-l+1)/3)
 
  stoogesort(array, l, (h-t))
 
  stoogesort(array, l+t, (h))
 
  stoogesort(array, l, (h-t))

arr = [1,2,3,4]
stoogesort(arr, 0, len(arr)-1)
print(max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1]))




#288 write a python program to print an array of the squares of each number sorted in non-decreasing order of a given array using stooge sort
def stoogesort(array, l, h):
 if l >= h:
  return

 if array[l]>array[h]:
  t = array[l]
  array[l] = array[h]
  array[h] = t
 
 if h-l+1 > 2:
  t = (int)((h-l+1)/3)
 
  stoogesort(array, l, (h-t))
 
  stoogesort(array, l+t, (h))
 
  stoogesort(array, l, (h-t))

arr = [-2,-1,0,3,4]
for i in range(len(arr)):
    arr[i] *= arr[i]
stoogesort(arr, 0, len(arr)-1)
print(arr)




# write a python program for Bubble Sort
def bubbleSort(array):
    swapped = False
    for i in range(len(array)-1,0,-1):
        for j in range(i):
            if array[j]>array[j+1]:
                array[j], array[j+1] = array[j+1], array[j]
                swapped= True
        if swapped:
            swapped=False
        else:
            break
    return array



# write a python function for Selection Sort
def selectionSort(array):
    for i in range(len(array)-1):
        min_idx = i
        for idx in range(i + 1, len(array)):
            if array[idx] < array[min_idx]:
                min_idx = idx
        array[i], array[min_idx] = array[min_idx], array[i]
    return array



# write a python program for Insertion Sort
def insertionSort(array):
    for i in range(1, len(array)):
        key = array[i]
        j = i-1
        while array[j] < key and j >= 0:
            array[j+1] = array[j]
            j -= 1
        array[j+1] = key
    return array



# write a python function for Shell Sort
import math
def shellSort(array):
    n = len(array)
    k = int(math.log2(n))
    interval = 2**k -1
    while interval > 0:
        for i in range(interval, n):
            temp = array[i]
            j = i
            while j >= interval and array[j - interval] < temp:
                array[j] = array[j - interval]
                j -= interval
            array[j] = temp
        k -= 1
        interval = 2**k -1
    return array



# write a python program for Heap Sort
def heapify(array, n, i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2
    if l < n and array[i] < array[l]:
        largest = l
    if r < n and array[largest] < array[r]:
        largest = r
    if largest != i:
        array[i], array[largest] = array[largest], array[i]
        heapify(array, n, largest)
def heapSort(array):
    n = len(array)
    for i in range(n//2, -1, -1):
        heapify(array, n, i)
    for i in range(n-1, 0, -1):
        array[i], array[0] = array[0], array[i]
        heapify(array, i, 0)
    return array



# write a python program for Merge Sort
def mergeSort(nums):
    if len(nums)==1:
        return nums
    mid = (len(nums)-1) // 2
    lst1 = mergeSort(nums[:mid+1])
    lst2 = mergeSort(nums[mid+1:])
    result = merge(lst1, lst2)
    return result
def merge(lst1, lst2):
    lst = []
    i = 0
    j = 0
    while(i<=len(lst1)-1 and j<=len(lst2)-1):
        if lst1[i]>lst2[j]:
            lst.append(lst1[i])
            i+=1
        else:
            lst.append(lst2[j])
            j+=1
    if i>len(lst1)-1:
        while(j<=len(lst2)-1):
            lst.append(lst2[j])
            j+=1
    else:
        while(i<=len(lst1)-1):
            lst.append(lst1[i])
            i+=1
    return lst



# write a python function for Quick Sort
def quickSort(array):
    if len(array)> 1:
        pivot=array.pop()
        grtr_lst, equal_lst, smlr_lst = [], [pivot], []
        for item in array:
            if item == pivot:
                equal_lst.append(item)
            elif item > pivot:
                grtr_lst.append(item)
            else:
                smlr_lst.append(item)
        return (quickSort(smlr_lst) + equal_lst + quickSort(grtr_lst))
    else:
        return array



# write a python program for Counting Sort
def countSort(array):
    i_lower_bound , upper_bound = min(array), max(array)
    lower_bound = i_lower_bound
    if i_lower_bound < 0:
        lb = abs(i_lower_bound)
        array = [item + lb for item in array]
        lower_bound , upper_bound = min(array), max(array)
    counter_array = [0]*(upper_bound-lower_bound+1)
    for item in array:
        counter_array[item-lower_bound] += 1
    pos = 0
    for idx, item in enumerate(counter_array):
        num = idx + lower_bound
        for i in range(item):
            array[pos] = num
            pos += 1
    if i_lower_bound < 0:
        lb = abs(i_lower_bound)
        array = [item - lb for item in array]
    return array



# write a python function for Radix Sort
import itertools
def radixSort(array):
    min_num = min(array)
    if min_num < 0:
        lb = abs(min_num)
        array = [item + lb for item in array]
    n_digits = len(str(max(array)))
    for dgt in range(n_digits):
        buckets = [[] for i in range(10)]
        for num in array:
            idx = (num // (10**dgt)) % 10
            buckets[idx].append(num)
        array = list(itertools.chain(*buckets))
    if min_num < 0:
        lb = abs(min_num)
        array = [item - lb for item in array]
    return array



# write a python function for Bucket Sort
def bucketSort(array):
    largest = max(array)
    length = len(array)
    size = largest/length
    buckets = [[] for i in range(length)]
    for i in range(length):
        index = int(array[i]/size)
        if index != length:
            buckets[index].append(array[i])
        else:
            buckets[length - 1].append(array[i])
    for i in range(len(array)):
        buckets[i] = sorted(buckets[i])
    result = []
    for i in range(length):
        result = result + buckets[i]
    return result



# write a python program for Random Pivot Quick Sort
import random

def partition(A, left_index, right_index):
    pivot = A[left_index]
    i = left_index + 1
    for j in range(left_index + 1, right_index):
        if A[j] < pivot:
            A[j], A[i] = A[i], A[j]
            i += 1
    A[left_index], A[i - 1] = A[i - 1], A[left_index]
    return i - 1

def quick_sort_random(A, left, right):
    if left < right:
        pivot = random.randint(left, right - 1)
        A[pivot], A[left] = (A[left], A[pivot])
        pivot_index = partition(A, left, right)
        quick_sort_random(A, left, pivot_index)
        quick_sort_random(A, pivot_index + 1, right)



# write a python program for Recursive Bubble Sort
def rec_bubble_sort(list_data: list, length: int = 0) -> list:
    length = length or len(list_data)
    swap = False
    for i in range(length - 1):
        if list_data[i] > list_data[i + 1]:
            list_data[i], list_data[i + 1] = list_data[i + 1], list_data[i]
            swap = True

    return list_data if not swap else rec_bubble_sort(list_data, length - 1)



# write a python function for Recursive Quick Sort
def rec_quick_sort(nums_list: list) -> list:
    if len(nums_list) <= 1:
        return nums_list
    else:
        return (rec_quick_sort([el for el in nums_list[1:] if el <= nums_list[0]]) + [nums_list[0]] + rec_quick_sort([el for el in nums_list[1:] if el > nums_list[0]]))



# write a python program for Strand Sort
mport operator
def strand_sort(num_arr: list, reverse: bool = False, solution: list = None) -> list:
    _operator = operator.lt if reverse else operator.gt
    solution = solution or []
    if not num_arr:
        return solution
    sublist = [num_arr.pop(0)]
    for k, item in enumerate(num_arr):
        if _operator(item, sublist[-1]):
            sublist.append(item)
            num_arr.pop(k)

    #  merging sublist into solution list
    if not solution:
        solution.extend(sublist)
    else:
        while sublist:
            item = sublist.pop(0)
            for j, xx in enumerate(solution):
                if not _operator(item, xx):
                    solution.insert(j, item)
                    break
            else:
                solution.append(item)

    strand_sort(num_arr, reverse, solution)
    return solution



# write a python function for Pancake Sort
def pancake_sort(nums_list):
    arr_len = len(nums_list)
    while arr_len > 1:
        mi = nums_list.index(max(nums_list[0:arr_len]))
        nums_list = nums_list[mi::-1] + nums_list[mi+1:len(nums_list)]
        nums_list = nums_list[arr_len-1::-1] + nums_list[arr_len:len(nums_list)]
        arr_len -= 1
    return nums_list



# write a python program for Iterative Quick Sort
def partition(arr,low,high):
    i = ( low - 1 )
    x = arr[high]
 
    for j in range(low , high):
        if   arr[j] <= x:
            i = i+1
            arr[i],arr[j] = arr[j],arr[i]
 
    arr[i+1],arr[high] = arr[high],arr[i+1]
    return (i+1)

def quickSortIterative(arr,low,high):
 
    size = high - low + 1
    stack = [0] * (size)
 
    top = -1
 
    top = top + 1
    stack[top] = low
    top = top + 1
    stack[top] = high
 
    while top >= 0:
        
        high = stack[top]
        top = top - 1
        low = stack[top]
        top = top - 1
 
        p = partition( arr, low, high )
        
        if p-1 > low:
            top = top + 1
            stack[top] = low
            top = top + 1
            stack[top] = p - 1
 
        if p+1 < high:
            top = top + 1
            stack[top] = p + 1
            top = top + 1
            stack[top] = high



# write a python function for Binary Insertion Sort
def binary_search(arr, val, start, end):
    if start == end:
        if arr[start] > val:
            return start
        else:
            return start+1

    if start > end:
        return start
 
    mid = int((start+end)/2)
    if arr[mid] < val:
        return binary_search(arr, val, mid+1, end)
    elif arr[mid] > val:
        return binary_search(arr, val, start, mid-1)
    else:
        return mid
 
def bin_insertion_sort(arr):
    for i in range(1, len(arr)):
        val = arr[i]
        j = binary_search(arr, val, 0, i-1)
        arr = arr[:j] + [val] + arr[j:i] + arr[i+1:]
    return arr



# write a python program for Iterative Merge Sort
def merge(left, right):
    if not len(left) or not len(right):
        return left or right
 
    result = []
    i, j = 0, 0
    while (len(result) < len(left) + len(right)):
        if left[i] < right[j]:
            result.append(left[i])
            i+= 1
        else:
            result.append(right[j])
            j+= 1
        if i == len(left) or j == len(right):
            result.extend(left[i:] or right[j:])
            break
 
    return result
 
def iter_merge_sort(list):
    if len(list) < 2:
        return list
 
    middle = int(len(list)/2)
    left = iter_merge_sort(list[:middle])
    right = iter_merge_sort(list[middle:])
 
    return merge(left, right)



# write a python program for Comb Sort
def getNextGap(gap):
    gap = (gap * 10)//13
    if gap < 1:
        return 1
    return gap
  
def combSort(arr):
    n = len(arr)
    gap = n
    swapped = True
    while gap !=1 or swapped == 1:
        gap = getNextGap(gap)
        swapped = False
        for i in range(0, n-gap):
            if arr[i] > arr[i + gap]:
                arr[i], arr[i + gap]=arr[i + gap], arr[i]
                swapped = True
    return arr



# write a python program for Pigeonhole Sort
def pigeonhole_sort(a):
    my_min = min(a)
    my_max = max(a)
    size = my_max - my_min + 1
  
    holes = [0] * size
  
    for x in a:
        assert type(x) is int, "integers only please"
        holes[x - my_min] += 1
  
    i = 0
    for count in range(size):
        while holes[count] > 0:
            holes[count] -= 1
            a[i] = count + my_min
            i += 1
    return a



# write a python program for Cocktail Sort
def cocktailSort(a):
    n = len(a)
    swapped = True
    start = 0
    end = n-1
    while (swapped == True):
        swapped = False
        for i in range(start, end):
            if (a[i] > a[i + 1]):
                a[i], a[i + 1] = a[i + 1], a[i]
                swapped = True
 
        if (swapped == False):
            break
 
        swapped = False
        end = end-1

        for i in range(end-1, start-1, -1):
            if (a[i] > a[i + 1]):
                a[i], a[i + 1] = a[i + 1], a[i]
                swapped = True

        start = start + 1



# write a python program for Gnome Sort
def gnomeSort(arr):
    n = len(arr)
    index = 0
    while index < n:
        if index == 0:
            index = index + 1
        if arr[index] >= arr[index - 1]:
            index = index + 1
        else:
            arr[index], arr[index-1] = arr[index-1], arr[index]
            index = index - 1
 
    return arr



# write a python program for Brick Sort
def BrickSort(l):
    n = len(l)
    is_Sorted = 0
    while is_Sorted == 0:
        is_Sorted = 1
        temp = 0
        for i in range(1, n-1, 2):
            if l[i] > l[i+1]:
                l[i], l[i+1] = l[i+1], l[i]
                is_Sorted = 0
                 
        for i in range(0, n-1, 2):
            if l[i] > l[i+1]:
                l[i], l[i+1] = l[i+1], l[i]
                is_Sorted = 0
     
    return l



# write a python program for Odd-Even Sort
def oddEvenSort(arr):
    n = len(arr)
    isSorted = 0
    while isSorted == 0:
        isSorted = 1
        temp = 0
        for i in range(1, n-1, 2):
            if arr[i] > arr[i+1]:
                arr[i], arr[i+1] = arr[i+1], arr[i]
                isSorted = 0
                 
        for i in range(0, n-1, 2):
            if arr[i] > arr[i+1]:
                arr[i], arr[i+1] = arr[i+1], arr[i]
                isSorted = 0
     
    return arr



# write a python program for Permutation Sort
import random

def is_sorted(l):
    n = len(l)
    for i in range(0, n-1):
        if (l[i] > l[i+1] ):
            return False
    return True
 
def shuffle(l):
    n = len(l)
    for i in range (0,n):
        r = random.randint(0,n-1)
        l[i], l[r] = l[r], l[i]
 
def PermutationSort(l):
    n = len(l)
    while (is_sorted(l)== False):
        shuffle(l)
    return l



# write a python program for Bogo Sort
import random

def is_sorted(l):
    n = len(l)
    for i in range(0, n-1):
        if (l[i] > l[i+1] ):
            return False
    return True
 
def shuffle(l):
    n = len(l)
    for i in range (0,n):
        r = random.randint(0,n-1)
        l[i], l[r] = l[r], l[i]
 
def BogoSort(l):
    n = len(l)
    while (is_sorted(l)== False):
        shuffle(l)
    return l



# write a python program for Cycle Sort
def cycleSort(array):

  for cycleStart in range(0, len(array) - 1):
    item = array[cycleStart]
     
    pos = cycleStart
    for i in range(cycleStart + 1, len(array)):
      if array[i] < item:
        pos += 1
     
    if pos == cycleStart:
      continue
     
    while item == array[pos]:
      pos += 1
    array[pos], item = item, array[pos]
     
    while pos != cycleStart:
       
      pos = cycleStart
      for i in range(cycleStart + 1, len(array)):
        if array[i] < item:
          pos += 1
       
      while item == array[pos]:
        pos += 1
      array[pos], item = item, array[pos]
   
  return array



# write a python program for Recursive Insertion Sort
def insertionSortRecursive(A, n):
    if n <= 1:
        return
 
    insertionSortRecursive(A, n - 1)
 
    last = A[n - 1]
    j = n - 2
 
    while (j >= 0 and A[j] > last):
        A[j + 1] = A[j]
        j = j - 1
    A[j + 1] = last



# write a python program for Stooge Sort
def stoogesort(array, l, h):
 if l >= h:
  return

 if array[l]>array[h]:
  t = array[l]
  array[l] = array[h]
  array[h] = t
 
 if h-l+1 > 2:
  t = (int)((h-l+1)/3)
 
  stoogesort(array, l, (h-t))
 
  stoogesort(array, l+t, (h))
 
  stoogesort(array, l, (h-t))



#87 Code for finding the second distinct largest number in an array using Heap Sort


#88 Write a program to find two integers that have minimum sum using odd-even sort


#89 Using Bogo Sort to find the middle integer of the array, assume the length is odd


#90 python program to find the largest integer that appears at most twice in an array using bucket sort


#91 write code to sort the squares of each element of an array in descending order using Permutation Sort


#92 using Cycle Sort, sort an input array and print the third maximum element


#93 code for removing the smallest number of the list and printing it in non-increasing order by using radix sort


#94 Program of finding the second smallest integer by utilizing stooge sort


#95 with recursive insertion sort, find an integer that appears exactly 2 times in the given array


#96 Write a python code to find the maximum sum of two integers using brick sort


#97 code of checking if it is possible to find four equal lengths in an array to form a square using Counting Sort 


#98 With Gnome Sort, sort an array in non-descending order and print the second last element


#99 Utilizing cocktail sort, find the third minimum number which is distinct


#100 write a program for sorting the cubes of each integer in the array with Pigeonhole Sort



